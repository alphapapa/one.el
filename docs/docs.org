* Home page
:PROPERTIES:
:ONE_IS_PAGE: t
:CUSTOM_ID: /
:END:

I'm the home page.

* About page
:PROPERTIES:
:ONE_IS_PAGE: t
:CUSTOM_ID: /about/
:END:

I'm the about page.

* 404
:PROPERTIES:
:ONE_IS_PAGE: t
:CUSTOM_ID: /404/
:END:

I'm the 404 page.

* Why one?
:PROPERTIES:
:ONE_IS_PAGE: t
:CUSTOM_ID: /why-one/
:END:

I wrote ~one~ to do *tech* blogging.

More precisely to talk about *programs* (not programming).

To me, it involves only three components:
1) chunks of code,
2) links to those chunks of code and,
3) the people (big thank you!!!) who wrote those chunks of code.

So, when I wrote it, I focused on those aspects.

As a result, I left out many org elements:
- I don't do math.  No support for Latex,
- I don't use images.  No support for images.
- etc.

You can find the complete list of the org elements that are not
supported in the commentary section of the file ~one.el~

* ----- Documentation -----
* org elements not supported
:PROPERTIES:
:ONE_IS_PAGE: t
:CUSTOM_ID: /doc/org-elements-not-supported/
:END:

I left out many org elements:

- I don't do math.  No support for Latex,
- I don't use images.  No support for images.
- etc.

You can find the complete list of the org elements that are not
supported in the commentary section of the file ~one.el~

Read more: [[#/why-one/][Why one?]].

* headline
:PROPERTIES:
:ONE_IS_PAGE: t
:CUSTOM_ID: /doc/headline/
:END:

Note that markups and links are not exported if used in headlines, only
the raw value string.

So don't use them in headlines.

* src-block
:PROPERTIES:
:ONE_IS_PAGE: t
:CUSTOM_ID: /doc/src-block/
:END:
** code highlighting with 'htmlize.el'
*** description

~one~ highlights code via the function ~one-ox-htmlize~ that uses
~htmlize.el~ to do the work.

For a given piece of code ~X~ in a certain language ~Y~, ~X~ will be
highlighted as it would be in the emacs mode ~Z~ used to edit ~Y~ code.

For instance, ~clojure-mode~ is used to highlight Clojure code and
~sh-mode~ is used to highlight Bash code.

Attributes of a face (like ~background-color~ or ~foreground-color~)
are not taken directly.  A generated name for the face is produced and
used as the CSS class for the parts of the code ~X~ that are highlighted
with that face.

For instance, in ~sh-mode~, the word ~echo~ is highlighted with the face
~font-lock-builtin-face~.  So, the word ~echo~ in a piece of Shell (or
Bash) code will be transformed into:

#+ATTR_ONE_RESULTS:
#+BEGIN_SRC html
<span class="one-hl-builtin">echo</span>
#+END_SRC

The whole piece of code ~X~, once the previously described operations
have been done, is wrapped:

1) for a /normal/ block by the component:

   #+ATTR_ONE_RESULTS:
   #+BEGIN_SRC html
   <pre><code class="one-hl one-hl-block">...</code></pre>
   #+END_SRC

2) for a /result/ block by the component:

   #+ATTR_ONE_RESULTS:
   #+BEGIN_SRC html
   <pre><code class="one-hl one-hl-results">...</code></pre>
   #+END_SRC

See section [[#/doc/src-block/#org-keywords-results-and-attr_one_results][org keywords RESULTS and ATTR_ONE_RESULTS]].

*** example with Bash code

For instance, the following org src-block, containing some ~bash~ code:

#+BEGIN_SRC text
,#+BEGIN_SRC bash
echo "list file's extensions in current dir:"
for f in `ls`; do
    echo ${f##*.}
done
,#+END_SRC
#+END_SRC

is exported as follow:

#+ATTR_ONE_RESULTS:
#+BEGIN_SRC html
<pre><code class="one-hl one-hl-block"><span class="one-hl-builtin">echo</span> <span class="one-hl-string">"list file's extensions in current dir:"</span>
<span class="one-hl-keyword">for</span> f<span class="one-hl-keyword"> in</span> <span class="one-hl-sh-quoted-exec">`ls`</span>; <span class="one-hl-keyword">do</span>
    <span class="one-hl-builtin">echo</span> ${<span class="one-hl-variable-name">f</span>##*.}
<span class="one-hl-keyword">done</span></code></pre>
</div>
#+END_SRC

and rendered like this:

#+BEGIN_SRC bash
echo "list file's extensions in current dir:"
for f in `ls`; do
    echo ${f##*.}
done
#+END_SRC

Note that ~one-ox-htmlize~ has produced and used the following CSS
classes (listed with their corresponding emacs faces):

#+BEGIN_SRC text
# from font-lock
one-hl-builtin        --> font-lock-builtin-face
one-hl-keyword        --> font-lock-keyword-face
one-hl-string         --> font-lock-string-face
one-hl-variable-name  --> font-lock-variable-name-face

# specific to sh-mode
one-hl-sh-quoted-exec --> sh-quoted-exec
#+END_SRC

You might have notice the pattern used for ~font-lock~ faces and the one
used for mode specific faces.

~one~ provides a style sheet that has the CSS classes defined for all
the ~font-lock~ faces (faces starting by ~font-lock-~) but not the
specific faces used by each prog mode (except the ones I use often).

You can add the CSS classes specific to the prog modes you use as you
go and need them.

*** Bash, Clojure and Elisp chunks of code

Bash, Clojure and Elisp languages are the ones I want to talk about.
And I'm sure they will appear in my tech writing.  So here they are:

Bash code:

#+BEGIN_SRC bash
echo "list file's extensions in current dir:"
for f in `ls`; do
    echo ${f##*.}
done
#+END_SRC

Clojure code:

#+BEGIN_SRC clojure
(defn str
  "With no args, returns the empty string. With one arg x, returns
  x.toString().  (str nil) returns the empty string. With more than
  one arg, returns the concatenation of the str values of the args."
  {:tag String
   :added "1.0"
   :static true}
  (^String [] "")
  (^String [^Object x]
   (if (nil? x) "" (. x (toString))))
  (^String [x & ys]
     ((fn [^StringBuilder sb more]
          (if more
            (recur (. sb  (append (str (first more)))) (next more))
            (str sb)))
      (new StringBuilder (str x)) ys)))
#+END_SRC

Elisp code:

#+BEGIN_SRC emacs-lisp
(defconst clojure-font-lock-keywords
  (eval-when-compile
    `( ;; Top-level variable definition
      (,(concat "(\\(?:clojure.core/\\)?\\("
                (regexp-opt '("def" "defonce"))
                ;; variable declarations
                "\\)\\>"
                ;; Any whitespace
                "[ \r\n\t]*"
                ;; Possibly type or metadata
                "\\(?:#?^\\(?:{[^}]*}\\|\\sw+\\)[ \r\n\t]*\\)*"
                "\\(\\sw+\\)?")
       (1 font-lock-keyword-face)
       (2 font-lock-variable-name-face nil t))
      ;; ...
      )))
#+END_SRC

** org keywords 'RESULTS' and 'ATTR_ONE_RESULTS'
:PROPERTIES:
:CUSTOM_ID: /doc/src-block/#org-keywords-results-and-attr_one_results
:END:

A *block* is considered to be a /result/ block:

1) if it is preceded by a line starting by ~#+RESULTS:~ or,
2) if it is preceded by a line starting by ~#+ATTR_ONE_RESULTS:~.

Blocks that are not /result/ blocks are /normal/ blocks.

When exported, /normal/ blocks and /result/ blocks differ only by their
CSS classes:
- ~one-hl one-hl-block~ for /normal/ blocks,
- ~one-hl one-hl-results~ for /result/ blocks.

This way /result/ blocks can be rendered with a different style
than /normal/ blocks as we can see in the following 2 examples.

*** example using org keyword 'RESULTS'

The following org snippet:

#+BEGIN_SRC text
,#+BEGIN_SRC bash :results output
ls
,#+END_SRC

,#+RESULTS:
: content.org
: one.css
: one.el
: README.org
#+END_SRC

is exported by ~one~ as follow:

#+ATTR_ONE_RESULTS:
#+BEGIN_SRC html
<pre><code class="one-hl one-hl-block">ls</code></pre>
<pre><code class="one-hl one-hl-results">content.org
one.css
one.el
README.org</code></pre>
#+END_SRC

and is rendered by ~one~ with the first block (/normal/ block) having a
different style from second block (/result/ block):

#+BEGIN_SRC bash :results output
ls
#+END_SRC

#+RESULTS:
: content.org
: one.css
: one.el
: README.org

*** example using org keyword 'ATTR_ONE_RESULTS'

The following org snippet:

#+BEGIN_SRC text
After evaluating this code block:

,#+BEGIN_SRC emacs-lisp
(plist-get '(:a "aaa" :b (:c "ccc" :d "ddd")) :b)
,#+END_SRC

we get:

,#+ATTR_ONE_RESULTS:
,#+BEGIN_SRC emacs-lisp
(:c "ccc" :d "ddd")
,#+END_SRC
#+END_SRC

is exported by ~one~ as follow:

#+ATTR_ONE_RESULTS:
#+BEGIN_SRC html
<p>After evaluating this code block:</p>
<pre><code class="one-hl one-hl-block">(plist-get '(<span class="one-hl-builtin">:a</span> <span class="one-hl-string">"aaa"</span> <span class="one-hl-builtin">:b</span> (<span class="one-hl-builtin">:c</span> <span class="one-hl-string">"ccc"</span> <span class="one-hl-builtin">:d</span> <span class="one-hl-string">"ddd"</span>)) <span class="one-hl-builtin">:b</span>)</code></pre>
<p>we get:</p>
<pre><code class="one-hl one-hl-results">(<span class="one-hl-builtin">:c</span> <span class="one-hl-string">"ccc"</span> <span class="one-hl-builtin">:d</span> <span class="one-hl-string">"ddd"</span>)</code></pre>
#+END_SRC

and is rendered by ~one~ like this:

After evaluating this code block:

#+BEGIN_SRC emacs-lisp
(plist-get '(:a "aaa" :b (:c "ccc" :d "ddd")) :b)
#+END_SRC

we get:

#+ATTR_ONE_RESULTS:
#+BEGIN_SRC emacs-lisp
(:c "ccc" :d "ddd")
#+END_SRC

** code blocks inside list

Lists can contain src-block as we can see in the following org
snippet:

#+BEGIN_SRC text
1. item 1

   ,#+BEGIN_SRC emacs-lisp
   (message "src-block in item 1")
   ,#+END_SRC

2. item 2
3. item 3
#+END_SRC

that is exported by ~one~ as follow:

#+ATTR_ONE_RESULTS:
#+BEGIN_SRC html
<ol>
  <li>
    <p>item 1</p>
    <pre><code class="one-hl one-hl-block">(message <span class="one-hl-string">"src-block in item 1"</span>)</code></pre>
  </li>
  <li><p>item 2</p></li>
  <li><p>item 3</p></li>
</ol>
#+END_SRC

and is rendered by ~one~ like this:

1. item 1

   #+BEGIN_SRC emacs-lisp
   (message "src-block in item 1")
   #+END_SRC

2. item 2
3. item 3

* quote-block
:PROPERTIES:
:ONE_IS_PAGE: t
:CUSTOM_ID: /doc/quote-block/
:END:

Blocks defined with ~#+BEGIN_QUOTE ... #+END_QUOTE~ pattern are
quote-block.

They are exported by ~one~ in a ~<blockquote>...</blockquote>~ component
with the CSS class ~one-blockquote~.

The following org snippet:

#+BEGIN_SRC text
,#+BEGIN_QUOTE
A quitter never wins and a winner never quits. —Napoleon Hill
,#+END_QUOTE
#+END_SRC

defines a quote and is exported by ~one~ as follow:

#+ATTR_ONE_RESULTS:
#+BEGIN_SRC html
<blockquote class="one-blockquote">A quitter never wins and a winner never quits. —Napoleon Hill</blockquote>
#+END_SRC

and look like this:

#+BEGIN_QUOTE
A quitter never wins and a winner never quits. —Napoleon Hill
#+END_QUOTE

* fixed-width and example-block
:PROPERTIES:
:ONE_IS_PAGE: t
:CUSTOM_ID: /doc/fixed-width-and-example-block/
:END:
** description

A line starting with a colon ~:~ followed by a space defined a
fixed-width element.  A fixed-width element can span several
lines.

fixed-width elements are blocks.

Blocks defined with ~#+BEGIN_EXAMPLE ... #+END_EXAMPLE~ pattern are
example-block elements.

Both fixed-width and example-block blocks are treated as [[#/doc/src-block/][src-block]] in
~text-mode~.  So:

1) they are highlighted as ~text-mode~ would do,
2) they are rendered in a ~<pre><code>...</code></pre>~ component
   (indentation and newlines are respected),
3) they are /normal/ blocks (with CSS classes ~one-hl one-hl-block~) *OR*
   /result/ blocks (with CSS classes ~one-hl one-hl-results~).

** example

The following org snippet:

#+BEGIN_SRC text
Here is a fixed-width element (one line):

: I'm a fixed-width element

fixed-width elements can also be used within lists:

- item 1
  : fixed-width element
- item 2
  ,#+ATTR_ONE_RESULTS:
  : multiline fixed-width element
  : that is also a result block,
  : so has a different style.

Although I don't often use example blocks, here is one:

,#+BEGIN_EXAMPLE
This    is
        an    example!
,#+END_EXAMPLE
#+END_SRC

is exported by ~one~ as follow:

#+ATTR_ONE_RESULTS:
#+BEGIN_SRC html
<p>Here is a fixed-width element (one line):</p>

<pre><code class="one-hl one-hl-block">I'm a fixed-width element</code></pre>

<p>fixed-width elements can also be used within lists:</p>

<ul>
  <li>
    <p>item 1</p>
    <pre><code class="one-hl one-hl-block">fixed-width element</code></pre>
  </li>
  <li>
    <p>item 2</p>
    <pre><code class="one-hl one-hl-results">multiline fixed-width element
that is also a result block,
so has a different style.</code></pre>
  </li>
</ul>

<p>Although I don&apos;t often use example blocks, here is one:</p>

<pre><code class="one-hl one-hl-block">This    is
        an    example!</code></pre>
#+END_SRC

and look like this:

Here is a fixed-width element (one line):

: I'm a fixed-width element

fixed-width elements can also be used within lists:

- item 1
  : fixed-width element
- item 2
  #+ATTR_ONE_RESULTS:
  : multiline fixed-width element
  : that is also a result block,
  : so has a different style.

Although I don't often use example blocks, here is one:

#+BEGIN_EXAMPLE
This    is
        an    example!
#+END_EXAMPLE

* links
:PROPERTIES:
:ONE_IS_PAGE: t
:CUSTOM_ID: /doc/links/
:END:
** http, https, mailto links

- http://tonyaldon.com,
- [[https://tonyaldon.com][Tony Aldon (https)]],
- [[mailto:aldon.tony.adm@gmail.com][send me an email]].

Web links (starting by ~http~ or ~https~) and links to message
composition (starting by ~mailto~) are exported as you expect.

For instance the following link:

#+BEGIN_SRC text
http://tonyaldon.com
#+END_SRC

is exported as follow:

#+ATTR_ONE_RESULTS:
#+BEGIN_SRC html
<a href="http://tonyaldon.com">http://tonyaldon.com</a>
#+END_SRC

and this following link with a description:

#+BEGIN_SRC text
[[https://tonyaldon.com][Tony Aldon (https)]]
#+END_SRC

is exported as follow:

#+ATTR_ONE_RESULTS:
#+BEGIN_SRC html
<a href="https://tonyaldon.com">Tony Aldon (https)</a>
#+END_SRC

and this ~mailto~ link:

#+BEGIN_SRC text
[[mailto:aldon.tony.adm@gmail.com][send me an email]]
#+END_SRC

is exported as follow:

#+ATTR_ONE_RESULTS:
#+BEGIN_SRC html
<a href="mailto:aldon.tony.adm@gmail.com">send me an email</a>
#+END_SRC

** custom-id links

- [[#/doc/plain-list-and-item/][page about plain-list]],
- [[#/doc/plain-list-and-item/#unordered-lists][unordered lists heading in the page about plain-list]].

*** description

In ~one~, ~CUSTOM_ID~ properties are:

- paths to pages (if the corresponding headline has also the property
  ~ONE_PAGE~ set to ~t~):

  #+BEGIN_SRC text
  ,* Page 1
  :PROPERTIES:
  :ONE_IS_PAGE: t
  :CUSTOM_ID: /blog/page-1/
  :END:
  #+END_SRC

- or paths to a specific heading (headline in org parlance) inside
  pages:

  #+BEGIN_SRC text
  ,* Page 1
  :PROPERTIES:
  :ONE_IS_PAGE: t
  :CUSTOM_ID: /blog/page-1/
  :END:
  ,** headline 1 in page Page 1
  :PROPERTIES:
  :CUSTOM_ID: /blog/page-1/#headline-1
  :END:
  #+END_SRC

Those paths define valid web urls starting at the root of the website
if you respect (you must):

1) url-encoded characters,
2) start them with a ~/~,
3) use ~#~ character to start the last part of the path when you're
   targeting a heading tag with its ~id~ being the last part after the ~#~
   character.

The benefits of these "rules/conventions" are:

1) ~one~ not need to compute anything regarding of the paths of the
   pages,
2) ~one~ can leave ~custom-id~ links as they are,
3) navigation between ~one~ pages (specific headlines) inside emacs
   using ~custom-id~ links is *not broken*!  (This is a big win for the
   writer of the blog who can enjoy his own blog inside emacs!!!).

Precisely, the following link to the ~custom-id~ equal to ~/blog/page-1/~:

#+BEGIN_SRC text
[[#/blog/page-1/][Page 1]]
#+END_SRC

is exported as follow:

#+ATTR_ONE_RESULTS:
#+BEGIN_SRC html
<a href="/blog/page-1/">Page 1</a>
#+END_SRC

*** example (link to a page)

The following link to the headline with ~CUSTOM_ID~ equal to
~/doc/plain-list-and-item/~ (that is also an ~one~ page):

#+BEGIN_SRC text
[[#/doc/plain-list-and-item/][page about plain-list]]
#+END_SRC

is exported to this anchor tag that links to the page ~/doc/plain-list-and-item/~:

#+ATTR_ONE_RESULTS:
#+BEGIN_SRC html
<a href="/doc/plain-list-and-item/">page about plain-list</a>
#+END_SRC

and is rendered like this: [[#/doc/plain-list-and-item/][page about plain-list]].

*** example (link to a headline in a page)

The following link to the headline with ~CUSTOM_ID~ equal to
~/doc/plain-list-and-item/#unordered-lists~ (that must be a subsection of the
~one~ page ~/doc/plain-list-and-item/~):

#+BEGIN_SRC text
[[#/doc/plain-list-and-item/#unordered-lists][unordered lists heading in the page about plain-list]]
#+END_SRC

is exported to this anchor tag that links to the heading with the ~id~
set to ~unordered-lists~ on the page ~/doc/plain-list-and-item/~:

#+ATTR_ONE_RESULTS:
#+BEGIN_SRC html
<a href="/doc/plain-list-and-item/#unordered-lists">unordered lists heading in the page about plain-list</a>
#+END_SRC

and is rendered like this: [[#/doc/plain-list-and-item/#unordered-lists][unordered lists heading in the page about
plain-list]].

** fuzzy links

# uncomment the last line of this comment (fuzzy search link),
# narrow the buffer to this subsection, and export the narrowed
# buffer with one.
# --> This must raise an error.
# --> [[fuzzy search]]

I don't use ~fuzzy~ links.  So, if there is a ~fuzzy~ link
in the document, that means I wrote the link wrong.

Broken links are bad user experience.  I don't like them.

So I decided that ~one~ raises an error (hard-coded) when we try to
export a fuzzy link to HTML.

For instance, the following ~fuzzy~ link:

#+BEGIN_SRC text
[[fuzzy search]]
#+END_SRC

raise an error like the following:

#+ATTR_ONE_RESULTS:
#+BEGIN_SRC text
(one-link-broken "fuzzy search" "fuzzy links not supported" "goto-char: 5523")
#+END_SRC

** file links
*** links to local files in the 'public' directory
:PROPERTIES:
:CUSTOM_ID: /doc/links/#local-files-in-public-dir
:END:

- [[./public/doc/plain-list-and-item.md][page about plain-list in markdown format]]

**** description

One might want to generate at build time files that are going to be
available in the ~public~ (root of the website) directory.
Those files not need to be ~one~ pages (that means not need to have
dedicated entries in this org file).

Those files, that are not ~one~ pages, can't be linked in this
org file with ~custom-id~ links (because those links would be broken
inside emacs, and we don't want that).

For those files, that will end up in the ~public~ directory after the
build, we can use local file links.  They will be exported removing
the ~./public~ part of the path making them accessible via web url.

It's convenient, because this way, after the build of the website,
those links stop being broken in this org file.

**** example

For instance, assuming the build of the website produces the markdown
file ~./public/doc/plain-list-and-item.md~ that is a markdown
version of the page ~/doc/plain-list-and-item/~, we can link
to that markdown file in this org file as follow:

#+BEGIN_SRC text
[[./public/doc/plain-list-and-item.md][page about plain-list in markdown format]]
#+END_SRC

This previous link is exported as follow:

#+ATTR_ONE_RESULTS:
#+BEGIN_SRC html
<a href="/doc/plain-list-and-item.md">page about plain-list in markdown format</a>
#+END_SRC

and is rendered like this: [[./public/doc/plain-list-and-item.md][page about plain-list in markdown format]].

*** links to local files in the 'assets' directory
:PROPERTIES:
:CUSTOM_ID: /doc/links/#local-files-in-assets-dir
:END:

- [[./assets/images/one.png][one image]]

**** description

Files in the directory ~assets~  are copied into the directory
~public~ (root of the website) when the website is built.

All file links pointing to files in the ~assets~ directory, once the
website has been built, will point to files in the directory ~public~.
The links will be exported removing the ~./assets~ part of the path
making them accessible via web url.

It's convenient, because this way:

1) we can "clean" the ~public~ directory whenever we need it and,
2) local file links in this org file are never broken.

**** example

For instance the following link:

#+BEGIN_SRC text
[[./assets/images/one.png][one image]]
#+END_SRC

is exported as follow:

#+ATTR_ONE_RESULTS:
#+BEGIN_SRC html
<a href="/images/one.png">one image</a>
#+END_SRC

and is rendered like this: [[./assets/images/one.png][one image]].

*** local file links that raise an error ('one-link-broken')
**** description

# uncomment the last line of this comment (unresolved file link),
# narrow the buffer to this subsection, and export the narrowed
# buffer with one.
# --> This must raise an error because:
#
#   1) the directory tmp is not a local relative file
#      in the root directory ./public/,
#   2) neither is a local relative file in the assets
#      directory ./assets/.
#
# --> [[/tmp/]]

Any file link that is not one of the following links:

1) [[#/doc/links/#local-files-in-public-dir][link to a local file in the public directory]],
2) [[#/doc/links/#local-files-in-assets-dir][link to a local file in the assets directory]],

raises an ~one-link-broken~ error when ~one~ try to export it.

**** example

Assuming we haven't declared an ~ONE_LINK~ mapping between the
directory ~/tmp/~ and any web url, the org file link:

#+BEGIN_SRC text
[[/tmp/]]
#+END_SRC

that is not in the ~public~ nor in the ~assets~ directory will raise (when
we try to export the link with ~one~) an error like the following:

#+ATTR_ONE_RESULTS:
#+BEGIN_SRC text
(one-link-broken "/tmp/" "goto-char: 26308")
#+END_SRC

* plain-list and item
:PROPERTIES:
:ONE_IS_PAGE: t
:CUSTOM_ID: /doc/plain-list-and-item/
:END:

Only /unordered/ and /ordered/ lists are supported.

** unordered lists
:PROPERTIES:
:CUSTOM_ID: /doc/plain-list-and-item/#unordered-lists
:END:

The following org snippet (unordered list):

#+BEGIN_SRC text
- a thing,
- another thing,
- and the last one.
#+END_SRC

is exported by ~one~ as follow:

#+ATTR_ONE_RESULTS:
#+BEGIN_SRC html
<ul>
  <li>
    <p>a thing,</p>
  </li>
  <li>
    <p>another thing,</p>
  </li>
  <li>
    <p>and the last one.</p>
  </li>
</ul>
#+END_SRC

and is rendered like this:

- a thing,
- another thing,
- and the last one.

** ordered list

The following org snippet (unordered list):

#+BEGIN_SRC text
1) first,
2) second,
3) third.
#+END_SRC

is exported by ~one~ as follow:

#+ATTR_ONE_RESULTS:
#+BEGIN_SRC html
<ol>
  <li>
    <p>a thing,</p>
  </li>
  <li>
    <p>another thing,</p>
  </li>
  <li>
    <p>and the last one.</p>
  </li>
</ol>
#+END_SRC

and is rendered like this:

1) first,
2) second,
3) third.
