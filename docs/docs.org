* one.el
:PROPERTIES:
:ONE: one-default-home
:CUSTOM_ID: /
:END:

Hi, I'm Tony Aldon and I'm glad that you're giving a try to ~one.el~, a
simple static site generator for Emacs Lisp programmers and org-mode
users.  I hope its design fits your workflow.

In ~one.el~, the following org file/buffer defines a website with 3
pages that we build by calling ~one-build~ command while we are visiting
it:

#+BEGIN_SRC org
,* My website
:PROPERTIES:
:ONE: one-default-home
:CUSTOM_ID: /
:END:

Welcome to my website!

,* Blog post 1
:PROPERTIES:
:ONE: one-default
:CUSTOM_ID: /blog/page-1/
:END:

My first blog post!

,* Blog post 2
:PROPERTIES:
:ONE: one-default
:CUSTOM_ID: /blog/page-2/
:END:

My second blog post!
#+END_SRC

The path ~/~ in the first ~CUSTOM_ID~ org property tells ~one.el~ that the
page "My website" is the home page.  That page is rendered using
~one-default-home~ render function, value of ~ONE~ org property of the
same headline.

The path ~/blog/page-1/~ in the second ~CUSTOM_ID~ org property tells
~one.el~ that we want to render "Blog post 1" page in such a way
that when we serve our website locally at ~http://localhost:3000~ for
instance, that page is served at ~http://localhost:3000/blog/page-1/~.
How that page is rendered is determined by the value of ~ONE~ org
property of the same headline which is ~one-default~, a render
function.

The same goes for the last page "Blog post 2".

As you might have noticed, a ~one.el~ website is an org file where the
pages are the headlines of level 1 with the org properties ~ONE~ and
~CUSTOM_ID~ set.  Nothing more!

~ONE~ is the only org property added by ~one.el~.  Its value (an Elisp
function which returns an HTML string) for a given page determines how
~one.el~ renders that page.

Paths of pages are set using ~CUSTOM_ID~ org property.

With that said, you might want to try it.

You can find the installation instructions [[#/docs/install-one-el/][here]] and be guided by the
[[#/docs/getting-started/][Getting started]] page.

** Why one.el?

I wrote ~one~ to do tech blogging.  More precisely to talk about
programs (not programming).

To me, it involves only three components:

1) chunks of code,
2) links to those chunks of code and,
3) the people (big thank you!!!) who wrote those chunks of code.

So, when I wrote it, I focused on those aspects.

As a result, I left out many org elements:

- I don't do math.  No support for Latex,
- I don't use table.  No support for tables,
- etc.

The org elements that are not supported are the following:
center-block, clock, drawer, dynamic-block, entity, export-block,
export-snippet, footnote-reference, horizontal-rule, inline-src-block,
inlinetask, keyword, latex-environment, latex-fragment, line-break,
node-property, planning, property-drawer, radio-target, special-block,
statistics-cookie, table, table-cell, table-row,target, timestamp,
verse-block

Note that "not supported" means they are not rendered by default by
~one.el~ but we can still use them or even extend ~one-ox~ org export
backend to take some of them into account.

* Install one.el
:PROPERTIES:
:ONE: one-default-doc
:CUSTOM_ID: /docs/install-one-el/
:END:

~one.el~ depends on ~jack~ and ~htmlize~ packages that are available on
[[https://melpa.org/][Melpa]].  Once you have them installed you can add ~one.el~ to your
~load-path~ and require it like this:

#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "/path/to/one.el/")
(require 'one)
#+END_SRC

If you're using ~straight.el~, to install ~one.el~ you just have to add
this sexp to your init file:

#+BEGIN_SRC emacs-lisp
(straight-use-package
 '(one :type git :host github :repo "tonyaldon/one.el"))
#+END_SRC

Now you can call the command ~one-default-new-project~ to create a new
project and visite the [[#/docs/getting-started/][Getting started]] page to be guided.

* Getting started
:PROPERTIES:
:ONE: one-default-doc
:CUSTOM_ID: /docs/getting-started/
:END:

If you're reading this from Emacs, that means you've already called
~one-default-new-project~ command and produced a ~one~ project with
the following structure:

#+BEGIN_SRC text
.
├── assets
│   └── one.css
└── one.org
#+END_SRC

If you didn't, start Emacs and in a new empty directory call
~one-default-new-project~ command.  Now you are in the org buffer
visiting the file ~one.org~ and you can go through this tutorial.

Let's build the website under the directory ~./public/~ by calling
~one-build~ command.  Our project's structure is now:

# FIXME: update the tree when the tutorial is terminated

#+BEGIN_SRC text
.
├── assets
│   └── one.css
├── one.org
└── public
    ├── blog
    │   ├── default
    │   │   └── index.html
    │   ├── getting-started
    │   │   └── index.html
    │   ├── one-default-doc
    │   │   └── index.html
    │   └── one-default-with-toc
    │       └── index.html
    ├── index.html
    └── one.css
#+END_SRC

To get our website up and running, we serve the files in ~./public/~
subdirectory using [[https://browsersync.io][brower-sync]] (any webserver serving files is OK).
Once we have it installed, to start a webserver with live reloading,
we run the following commands (in a terminal):

#+BEGIN_SRC text
$ cd public
$ browser-sync start -s -w --files "*"
#+END_SRC

Assuming the port ~3000~ isn't used we have our website served at
~http://localhost:3000~.

Finally:

1) in our browser we visit the page
   ~http://localhost:3000/docs/getting-started/~,
2) after this paragraph we write 'Hello world!',
3) then we call ~one-build~ command again and
4) we watch the changes live in our browser.

Cool, right?

* How does one.el work?
:PROPERTIES:
:ONE: one-default-doc
:CUSTOM_ID: /docs/how-does-one-el-work/
:END:

This page is rendered with the default render function ~one-default~
specified in ~ONE~ org property.  The path of the page is specified in
~CUSTOM_ID~ org property.  Notice that it starts with a slash ~/~ and end
with a slash ~/~.

** Do you want a table of content?

As we can see, ~one-default~ doesn't add a table of content (TOC). If we
want a default render function that adds the TOC to the page we can
use the render function ~one-default-with-toc~ presented in [[#/docs/one-default-with-toc/][The default
page with a TOC]].

** Links to pages

Note that the previous links is written in the org file like this

#+BEGIN_SRC text
[[#/docs/one-default-with-toc/][The default page with a TOC]]
#+END_SRC

making it an internal org link that targets the entry in the same file
with the ~CUSTOM_ID~ property set to ~/docs/one-default-with-toc/~ and the
render function ~one-default~ renders it like this:

#+BEGIN_SRC html
<a href="/docs/one-default-with-toc/">The default page with a TOC</a>
#+END_SRC

The advantage of doing this is that the navigation between pages
(level 1 headlines with ~ONE~ and ~CUSTOM_ID~ org properties set) inside
Emacs is the same as in the browser once the website has been built.

** Why does one-default render links in this way?

This is because ~one-default~ render function uses ~one~ org export
backend internally to convert the parsed tree of this page into an
HTML string.  And ~one~ backend is designed to do the right thing for
links, code blocks and headlines in the context of ~one~.

To convert the parsed tree of this page into an HTML string,
~one-default~ uses the function ~org-export-data-with-backend~ like this

#+BEGIN_SRC emacs-lisp
(org-export-data-with-backend
 (org-element-contents page-tree)
 'one nil)
#+END_SRC

where ~page-tree~ is the parsed tree of the entry of this page given as
the first argument of ~one-default~.

** But what is a render function?

A render function is a regular Elisp function that takes 3 arguments

- ~page-tree~: corresponding to the parsed tree of the org entry defining
  the page,
- ~pages~: list of pages,
- ~global~: a plist of global informations that are computed once
  in ~one-render-pages~ (see ~one-add-to-global~) before rendering the
  pages

and returns an HTML string.

For instance, the following ~hello-world~ function

#+BEGIN_SRC emacs-lisp
(defun hello-world (page-tree pages global)
      "<h1>Hello world!</h1>")
#+END_SRC

defined a valid render function.  We can use it to build a website
like this.  In an empty directory, we create a file named ~one.org~ with
the following content:

#+BEGIN_SRC org
,* The home page
:PROPERTIES:
:ONE: hello-world
:CUSTOM_ID: /
:END:
,* Blog post 1
:PROPERTIES:
:ONE: hello-world
:CUSTOM_ID: /blog/page-1/
:END:
#+END_SRC

We visit that file and call ~one-build~ command.  It produces the following files

#+BEGIN_SRC text
.
├── one.org (already there)
└── public
    ├── blog
    │   └── page-1
    │       └── index.html
    └── index.html
#+END_SRC

and the content of the files ~./public/blog/page-1/index.html~ and
~./public/index.html~ is

#+BEGIN_SRC html
<h1>Hello world!</h1>
#+END_SRC

Therefore if we serve the website in ~./public/~ directory at
~http://localhost:3000~ we can access the two "Hello world!" pages
at ~http://localhost:3000/blog/page-1/~ and ~http://localhost:3000~.

To facilitate the generation of the HTML strings in render functions
we can use the package [[https://jack.tonyaldon.com][Jack]] as in ~one-default~ function:

#+BEGIN_SRC emacs-lisp
(defun one-default (page-tree pages global)
  "..."
  (let* ((title (org-element-property :raw-value page-tree))
         (path (org-element-property :CUSTOM_ID page-tree))
         (content (org-export-data-with-backend
                   (org-element-contents page-tree)
                   'one nil))
         (website-name (one-default-website-name pages))
         (nav (one-default-nav path pages)))
    (jack-html
     "<!DOCTYPE html>"
     `(:html
       (:head
        (:meta (@ :name "viewport" :content "width=device-width,initial-scale=1"))
        (:link (@ :rel "stylesheet" :type "text/css" :href "/one.css"))
        (:title ,title))
       (:body
        (:div.header (:a (@ :href "/") ,website-name))
        (:div.content
         (:div.title (:h1 ,title))
         ,content
         ,nav))))))
#+END_SRC

** TODO But how is the website built?

Good question!

From an org file (or only buffer) containing all the pages of our
website we can build the website under ~./public/~ subdirectory
by calling either ~one-build~ or ~one-render-pages~.

The difference between those two commands is that before producing the
HTML pages calling ~one-render-pages~, ~one-build~ command cleans the
subdirectory ~./public/~ and copies the content of ~./assets/~ subdirectory
into ~./public/~ subdirectory.

So all the interesting work is done by ~one-render-pages~ command.
When we call it in an org buffer containing all our pages,
~one-render-pages~ does the following:

1) set ~tree~ local variable to the parsed tree of the current org
   buffer,
2) set ~pages~ local variable to the list of pages in ~tree~,
3) set ~global~ local variable according to the information in
   ~one-add-to-global~ user variable,
4) call the functions in ~one-hook~ with the previously computed
   variables ~tree~, ~pages~ and ~global~ as arguments,
5) finally produce the HTML pages in ~./public/~ subdirectory doing the
   following.  For each ~page~ in ~pages~:
   - set ~path~, ~render-page-function~, ~page-tree~ local variables
     using respectively the values of the properties ~:one-path~,
     ~:one-render-page-function~, ~:one-page-tree~ in ~page~ property list,
   - fill the content of a new created file ~index.html~ in the
     subdirectory ~path~ with the HTML string generated by
     ~render-page-function~ function called with ~page-tree~, ~pages~ and
     ~global~ as arguments.

Here is the complete implementation of ~one-render-pages~:

#+BEGIN_SRC emacs-lisp
(defun one-render-pages ()
  "..."
  (interactive)
  (let* ((tree (one-parse-buffer))
         (pages (one-list-pages tree))
         (global
          (let (global)
            (dolist (glob one-add-to-global)
              (push (funcall (plist-get glob :one-global-function) pages tree)
                    global)
              (push (plist-get glob :one-global-property) global))
            global)))
    (dolist (hook one-hook) (funcall hook pages tree global))
    (dolist (page pages)
      (let* ((path (concat "./public" (plist-get page :one-path)))
             (file (concat path "index.html"))
             (render-page-function (plist-get page :one-render-page-function))
             (page-tree (plist-get page :one-page-tree)))
        (make-directory path t)
        (with-temp-file file
          (insert (funcall render-page-function page-tree pages global)))))))
#+END_SRC


* Default pages
:PROPERTIES:
:ONE: one-default-doc
:CUSTOM_ID: /docs/default-pages/
:END:
** TODO The default page
:PROPERTIES:
:ONE: one-default
:CUSTOM_ID: /docs/default/
:END:

This page is rendered with the default render function ~one-default~
specified in ~ONE~ org property.  The path of the page is specified in
~CUSTOM_ID~ org property.  Notice that it starts with a slash ~/~ and end
with a slash ~/~.

*** Do you want a table of content?

As we can see, ~one-default~ doesn't add a table of content (TOC). If we
want a default render function that adds the TOC to the page we can
use the render function ~one-default-with-toc~ presented in [[#/docs/one-default-with-toc/][The default
page with a TOC]].

** TODO The default page with a TOC
:PROPERTIES:
:ONE: one-default-with-toc
:CUSTOM_ID: /docs/one-default-with-toc/
:END:

This page is rendered with the render function ~one-default-with-toc~
specified in the org property ~ONE~.

*** Do you want a sidebar?

Perhaps we want a sidebar listing all the pages on your website, as
many modern documentation sites do.  If so, we can use the default
render function ~one-default-doc~ presented in [[#/docs/one-default-doc/][The default page with TOC
and sidebar]].

** TODO The default page with TOC and sidebar
:PROPERTIES:
:ONE: one-default-doc
:CUSTOM_ID: /docs/one-default-doc/
:END:

This page is rendered with the function ~one-default-doc~ specified
in the org property ~ONE~.

*** headline 1
**** headline 1.1

foo

**** headline 1.2

bar

*** headline 2
** TODO Alternative default render function for the home page
:PROPERTIES:
:ONE: one-default-home
:CUSTOM_ID: /default-home/
:END:

# This page is rendered with the default render function
# ~one-default-home-list-pages~ specified in ~ONE~ org property.  Being the
# website's home page, its path specified in ~CUSTOM_ID~ org property is
# set to one slash ~/~.
#
# Thus this text is inserted before we list the website's pages (in
# reverse order of appearance in the org document).
#
# We can change this page's appearance by modifying the CSS ids
# ~home-list-pages~ and ~pages~, and the CSS classes ~header~ and ~content~.
#
# And if we don't want to list the website's pages we can use the
# default render function ~one-default-home~ presented in [[#/default-home/][Alternative
# default render function for the home page]].


# This page is rendered with the default render function ~one-default-home~
# specified in ~ONE~ org property.
#
# And as we can see the website's pages are not listed and the content
# is rendered "normaly" (not text centered as in the [[#/][home page]]).
#
# We can change this page's appearance by modifying the CSS id
# ~home~ and the CSS classes ~header~ and ~content~.
#
# Let's move on to [[#/blog/default/][The default page]].

* one-ox | org elements not supported
:PROPERTIES:
:ONE: one-default-doc
:CUSTOM_ID: /docs/org-elements-not-supported/
:END:

I left out many org elements:

- I don't do math.  No support for Latex,
- I don't use images.  No support for images.
- etc.

You can find the complete list of the org elements that are not
supported in the commentary section of the file ~one.el~

Read more: [[#/why-one/][Why one?]].

* one-ox | headline
:PROPERTIES:
:ONE: one-default-doc
:CUSTOM_ID: /docs/headline/
:END:

Note that markups and links are not exported if used in headlines, only
the raw value string.

So don't use them in headlines.

* one-ox | src-block
:PROPERTIES:
:ONE: one-default-doc
:CUSTOM_ID: /docs/src-block/
:END:
** Code highlighting with 'htmlize.el'
*** Description

~one~ highlights code via the function ~one-ox-htmlize~ that uses
~htmlize.el~ to do the work.

For a given piece of code ~X~ in a certain language ~Y~, ~X~ will be
highlighted as it would be in the emacs mode ~Z~ used to edit ~Y~ code.

For instance, ~clojure-mode~ is used to highlight Clojure code and
~sh-mode~ is used to highlight Bash code.

Attributes of a face (like ~background-color~ or ~foreground-color~)
are not taken directly.  A generated name for the face is produced and
used as the CSS class for the parts of the code ~X~ that are highlighted
with that face.

For instance, in ~sh-mode~, the word ~echo~ is highlighted with the face
~font-lock-builtin-face~.  So, the word ~echo~ in a piece of Shell (or
Bash) code will be transformed into:

#+BEGIN_SRC html
<span class="one-hl-builtin">echo</span>
#+END_SRC

The whole piece of code ~X~, once the previously described operations
have been done, is wrapped:

1) for a normal block by the component:

   #+BEGIN_SRC html
   <pre><code class="one-hl one-hl-block">...</code></pre>
   #+END_SRC

2) for a result block by the component:

   #+BEGIN_SRC html
   <pre><code class="one-hl one-hl-results">...</code></pre>
   #+END_SRC

See section [[#/docs/src-block/#org-keywords-results-and-attr_one_results][org keywords RESULTS and ATTR_ONE_RESULTS]].

*** Example with Bash code

For instance, the following org src-block, containing some ~bash~ code:

#+BEGIN_SRC text
,#+BEGIN_SRC bash
echo "list file's extensions in current dir:"
for f in `ls`; do
    echo ${f##*.}
done
,#+END_SRC
#+END_SRC

is exported as follow:

#+BEGIN_SRC html
<pre><code class="one-hl one-hl-block"><span class="one-hl-builtin">echo</span> <span class="one-hl-string">"list file's extensions in current dir:"</span>
<span class="one-hl-keyword">for</span> f<span class="one-hl-keyword"> in</span> <span class="one-hl-sh-quoted-exec">`ls`</span>; <span class="one-hl-keyword">do</span>
    <span class="one-hl-builtin">echo</span> ${<span class="one-hl-variable-name">f</span>##*.}
<span class="one-hl-keyword">done</span></code></pre>
</div>
#+END_SRC

and rendered like this:

#+BEGIN_SRC bash
echo "list file's extensions in current dir:"
for f in `ls`; do
    echo ${f##*.}
done
#+END_SRC

Note that ~one-ox-htmlize~ has produced and used the following CSS
classes (listed with their corresponding emacs faces):

#+BEGIN_SRC text
# from font-lock
one-hl-builtin        --> font-lock-builtin-face
one-hl-keyword        --> font-lock-keyword-face
one-hl-string         --> font-lock-string-face
one-hl-variable-name  --> font-lock-variable-name-face

# specific to sh-mode
one-hl-sh-quoted-exec --> sh-quoted-exec
#+END_SRC

You might have notice the pattern used for ~font-lock~ faces and the one
used for mode specific faces.

~one~ provides a style sheet that has the CSS classes defined for all
the ~font-lock~ faces (faces starting by ~font-lock-~) but not the
specific faces used by each prog mode (except the ones I use often).

You can add the CSS classes specific to the prog modes you use as you
go and need them.

** Org keywords 'RESULTS'
:PROPERTIES:
:CUSTOM_ID: /docs/src-block/#org-keywords-results-and-attr_one_results
:END:

Result blocks are preceded by line starting by ~#+RESULTS:~.

Blocks that are not result blocks are normal blocks.

When exported, normal blocks and result blocks differ only by their
CSS classes:

- ~one-hl one-hl-block~ for normal blocks,
- ~one-hl one-hl-results~ for result blocks.

This way result blocks can be rendered with a different style
than normal blocks as we can see in the following 2 examples.

*** Example using org keyword 'RESULTS'

The following org snippet:

#+BEGIN_SRC text
,#+BEGIN_SRC bash :results output
ls
,#+END_SRC

,#+RESULTS:
: content.org
: one.css
: one.el
: README.org
#+END_SRC

is exported by ~one~ as follow:

#+BEGIN_SRC html
<pre><code class="one-hl one-hl-block">ls</code></pre>
<pre><code class="one-hl one-hl-results">content.org
one.css
one.el
README.org</code></pre>
#+END_SRC

and is rendered by ~one~ with the first block (normal block) having a
different style from second block (result block):

#+BEGIN_SRC bash :results output
ls
#+END_SRC

#+RESULTS:
: content.org
: one.css
: one.el
: README.org

** Code blocks inside list

Lists can contain src-block as we can see in the following org
snippet:

#+BEGIN_SRC text
1. item 1

   ,#+BEGIN_SRC emacs-lisp
   (message "src-block in item 1")
   ,#+END_SRC

2. item 2
3. item 3
#+END_SRC

that is exported by ~one~ as follow:

#+BEGIN_SRC html
<ol>
  <li>
    <p>item 1</p>
    <pre><code class="one-hl one-hl-block">(message <span class="one-hl-string">"src-block in item 1"</span>)</code></pre>
  </li>
  <li><p>item 2</p></li>
  <li><p>item 3</p></li>
</ol>
#+END_SRC

and is rendered by ~one~ like this:

1. item 1

   #+BEGIN_SRC emacs-lisp
   (message "src-block in item 1")
   #+END_SRC

2. item 2
3. item 3

* one-ox | quote-block
:PROPERTIES:
:ONE: one-default-doc
:CUSTOM_ID: /docs/quote-block/
:END:

Blocks defined with ~#+BEGIN_QUOTE ... #+END_QUOTE~ pattern are
quote-block.

They are exported by ~one~ in a ~<blockquote>...</blockquote>~ component
with the CSS class ~one-blockquote~.

The following org snippet:

#+BEGIN_SRC text
,#+BEGIN_QUOTE
A quitter never wins and a winner never quits. —Napoleon Hill
,#+END_QUOTE
#+END_SRC

defines a quote and is exported by ~one~ as follow:

#+BEGIN_SRC html
<blockquote class="one-blockquote"><p>A quitter never wins and a winner never quits. —Napoleon Hill</p></blockquote>
#+END_SRC

and look like this:

#+BEGIN_QUOTE
A quitter never wins and a winner never quits. —Napoleon Hill
#+END_QUOTE

* one-ox | fixed-width and example-block
:PROPERTIES:
:ONE: one-default-doc
:CUSTOM_ID: /docs/fixed-width-and-example-block/
:END:
** Description

A line starting with a colon ~:~ followed by a space defined a
fixed-width element.  A fixed-width element can span several
lines.

fixed-width elements are blocks.

Blocks defined with ~#+BEGIN_EXAMPLE ... #+END_EXAMPLE~ pattern are
example-block elements.

Both fixed-width and example-block blocks are treated as [[#/docs/src-block/][src-block]] in
~text-mode~.  So:

1) they are highlighted as ~text-mode~ would do,
2) they are rendered in a ~<pre><code>...</code></pre>~ component
   (indentation and newlines are respected),
3) they are normal blocks (with CSS classes ~one-hl one-hl-block~) *OR*
   result blocks (with CSS classes ~one-hl one-hl-results~).

** Example

The following org snippet:

#+BEGIN_SRC text
Here is a fixed-width element (one line):

: I'm a fixed-width element

fixed-width elements can also be used within lists:

- item 1
  : fixed-width element
- item 2
  : multiline fixed-width element
  : that is also a result block,
  : so has a different style.

Although I don't often use example blocks, here is one:

,#+BEGIN_EXAMPLE
This    is
        an    example!
,#+END_EXAMPLE
#+END_SRC

is exported by ~one~ as follow:

#+BEGIN_SRC html
<p>Here is a fixed-width element (one line):</p>

<pre><code class="one-hl one-hl-block">I'm a fixed-width element</code></pre>

<p>fixed-width elements can also be used within lists:</p>

<ul>
  <li>
    <p>item 1</p>
    <pre><code class="one-hl one-hl-block">fixed-width element</code></pre>
  </li>
  <li>
    <p>item 2</p>
    <pre><code class="one-hl one-hl-block">multiline fixed-width element
that is also a result block,
so has a different style.</code></pre>
  </li>
</ul>

<p>Although I don&apos;t often use example blocks, here is one:</p>

<pre><code class="one-hl one-hl-block">This    is
        an    example!</code></pre>
#+END_SRC

and look like this:

Here is a fixed-width element (one line):

: I'm a fixed-width element

fixed-width elements can also be used within lists:

- item 1
  : fixed-width element
- item 2
  : multiline fixed-width element
  : that is also a result block,
  : so has a different style.

Although I don't often use example blocks, here is one:

#+BEGIN_EXAMPLE
This    is
        an    example!
#+END_EXAMPLE

* one-ox | links
:PROPERTIES:
:ONE: one-default-doc
:CUSTOM_ID: /docs/links/
:END:
** http, https, mailto links

- http://tonyaldon.com,
- [[https://tonyaldon.com][Tony Aldon (https)]],
- [[mailto:aldon.tony.adm@gmail.com][send me an email]].

Web links (starting by ~http~ or ~https~) and links to message
composition (starting by ~mailto~) are exported as you expect.

For instance the following link:

#+BEGIN_SRC text
http://tonyaldon.com
#+END_SRC

is exported as follow:

#+BEGIN_SRC html
<a href="http://tonyaldon.com">http://tonyaldon.com</a>
#+END_SRC

and this following link with a description:

#+BEGIN_SRC text
[[https://tonyaldon.com][Tony Aldon (https)]]
#+END_SRC

is exported as follow:

#+BEGIN_SRC html
<a href="https://tonyaldon.com">Tony Aldon (https)</a>
#+END_SRC

and this ~mailto~ link:

#+BEGIN_SRC text
[[mailto:aldon.tony.adm@gmail.com][send me an email]]
#+END_SRC

is exported as follow:

#+BEGIN_SRC html
<a href="mailto:aldon.tony.adm@gmail.com">send me an email</a>
#+END_SRC

** Custom ID links

- [[#/docs/plain-list-and-item/][page about plain-list]],
- [[#/docs/plain-list-and-item/#unordered-lists][unordered lists heading in the page about plain-list]].

*** Description

In ~one~, ~CUSTOM_ID~ properties are:

- paths to pages (if the corresponding headline has also the property
  ~ONE_PAGE~ set to ~t~):

  #+BEGIN_SRC text
  ,* Page 1
  :PROPERTIES:
  :ONE: t
  :CUSTOM_ID: /blog/page-1/
  :END:
  #+END_SRC

- or paths to a specific heading (headline in org parlance) inside
  pages:

  #+BEGIN_SRC text
  ,* Page 1
  :PROPERTIES:
  :ONE: t
  :CUSTOM_ID: /blog/page-1/
  :END:
  ,** headline 1 in page Page 1
  :PROPERTIES:
  :CUSTOM_ID: /blog/page-1/#headline-1
  :END:
  #+END_SRC

Those paths define valid web urls starting at the root of the website
if you respect (you must):

1) url-encoded characters,
2) start them with a ~/~ and end them with ~/~,
3) use ~#~ character to start the last part of the path when you're
   targeting a heading tag with its ~id~ being the last part after the ~#~
   character.

The benefits of these "rules/conventions" are:

1) ~one~ not need to compute anything regarding of the paths of the
   pages,
2) ~one~ can leave ~custom-id~ links as they are,
3) navigation between ~one~ pages (specific headlines) inside emacs
   using ~custom-id~ links is not broken!  (This is a big win for the
   writer of the blog who can enjoy his own blog inside emacs!!!).

Precisely, the following link to the ~custom-id~ equal to ~/blog/page-1/~:

#+BEGIN_SRC text
[[#/blog/page-1/][Page 1]]
#+END_SRC

is exported as follow:

#+BEGIN_SRC html
<a href="/blog/page-1/">Page 1</a>
#+END_SRC

*** Example (link to a page)

The following link to the headline with ~CUSTOM_ID~ equal to
~/docs/plain-list-and-item/~ (that is also an ~one~ page):

#+BEGIN_SRC text
[[#/docs/plain-list-and-item/][page about plain-list]]
#+END_SRC

is exported to this anchor tag that links to the page ~/docs/plain-list-and-item/~:

#+BEGIN_SRC html
<a href="/docs/plain-list-and-item/">page about plain-list</a>
#+END_SRC

and is rendered like this: [[#/docs/plain-list-and-item/][page about plain-list]].

*** Example (link to a headline in a page)

The following link to the headline with ~CUSTOM_ID~ equal to
~/docs/plain-list-and-item/#unordered-lists~ (that must be a subsection of the
~one~ page ~/docs/plain-list-and-item/~):

#+BEGIN_SRC text
[[#/docs/plain-list-and-item/#unordered-lists][unordered lists heading in the page about plain-list]]
#+END_SRC

is exported to this anchor tag that links to the heading with the ~id~
set to ~unordered-lists~ on the page ~/docs/plain-list-and-item/~:

#+BEGIN_SRC html
<a href="/docs/plain-list-and-item/#unordered-lists">unordered lists heading in the page about plain-list</a>
#+END_SRC

and is rendered like this: [[#/docs/plain-list-and-item/#unordered-lists][unordered lists heading in the page about
plain-list]].

** Fuzzy links

# uncomment the last line of this comment (fuzzy search link),
# narrow the buffer to this subsection, and export the narrowed
# buffer with one.
# --> This must raise an error.
# --> [[fuzzy search]]

I don't use ~fuzzy~ links.  So, if there is a ~fuzzy~ link
in the document, that means I wrote the link wrong.

Broken links are bad user experience.  I don't like them.

So I decided that ~one~ raises an error (hard-coded) when we try to
export a fuzzy link to HTML.

For instance, the following ~fuzzy~ link:

#+BEGIN_SRC text
[[fuzzy search]]
#+END_SRC

raise an error like the following:

#+BEGIN_SRC text
(one-link-broken "fuzzy search" "fuzzy links not supported" "goto-char: 5523")
#+END_SRC

** File links
*** Links to local files in the 'public' directory
:PROPERTIES:
:CUSTOM_ID: /docs/links/#local-files-in-public-dir
:END:

- [[./public/docs/plain-list-and-item.md][page about plain-list in markdown format]]

**** Description

One might want to generate at build time files that are going to be
available in the ~public~ (root of the website) directory.
Those files not need to be ~one~ pages (that means not need to have
dedicated entries in this org file).

Those files, that are not ~one~ pages, can't be linked in this
org file with ~custom-id~ links (because those links would be broken
inside emacs, and we don't want that).

For those files, that will end up in the ~public~ directory after the
build, we can use local file links.  They will be exported removing
the ~./public~ part of the path making them accessible via web url.

It's convenient, because this way, after the build of the website,
those links stop being broken in this org file.

**** Example

For instance, assuming the build of the website produces the markdown
file ~./public/docs/plain-list-and-item.md~ that is a markdown
version of the page ~/docs/plain-list-and-item/~, we can link
to that markdown file in this org file as follow:

#+BEGIN_SRC text
[[./public/docs/plain-list-and-item.md][page about plain-list in markdown format]]
#+END_SRC

This previous link is exported as follow:

#+BEGIN_SRC html
<a href="/docs/plain-list-and-item.md">page about plain-list in markdown format</a>
#+END_SRC

and is rendered like this: [[./public/docs/plain-list-and-item.md][page about plain-list in markdown format]].

*** Links to local files in the 'assets' directory
:PROPERTIES:
:CUSTOM_ID: /docs/links/#local-files-in-assets-dir
:END:

- [[./assets/images/one.png][one image]]

**** Description

Files in the directory ~assets~  are copied into the directory
~public~ (root of the website) when the website is built.

All file links pointing to files in the ~assets~ directory, once the
website has been built, will point to files in the directory ~public~.
The links will be exported removing the ~./assets~ part of the path
making them accessible via web url.

It's convenient, because this way:

1) we can "clean" the ~public~ directory whenever we need it and,
2) local file links in this org file are never broken.

**** Example

For instance the following link:

#+BEGIN_SRC text
[[./assets/images/one.png][one image]]
#+END_SRC

is exported as follow:

#+BEGIN_SRC html
<a href="/images/one.png">one image</a>
#+END_SRC

and is rendered like this: [[./assets/images/one.png][one image]].

*** Local file links that raise an error ('one-link-broken')
**** Description

# uncomment the last line of this comment (unresolved file link),
# narrow the buffer to this subsection, and export the narrowed
# buffer with one.
# --> This must raise an error because:
#
#   1) the directory tmp is not a local relative file
#      in the root directory ./public/,
#   2) neither is a local relative file in the assets
#      directory ./assets/.
#
# --> [[/tmp/]]

Any file link that is not one of the following links:

1) [[#/docs/links/#local-files-in-public-dir][link to a local file in the public directory]],
2) [[#/docs/links/#local-files-in-assets-dir][link to a local file in the assets directory]],

raises an ~one-link-broken~ error when ~one~ try to export it.

**** Example

Assuming we haven't declared an ~ONE_LINK~ mapping between the
directory ~/tmp/~ and any web url, the org file link:

#+BEGIN_SRC text
[[/tmp/]]
#+END_SRC

that is not in the ~public~ nor in the ~assets~ directory will raise (when
we try to export the link with ~one~) an error like the following:

#+BEGIN_SRC text
(one-link-broken "/tmp/" "goto-char: 26308")
#+END_SRC

* one-ox | plain-list and item
:PROPERTIES:
:ONE: one-default-doc
:CUSTOM_ID: /docs/plain-list-and-item/
:END:

Only unordered and ordered lists are supported.

** Unordered lists
:PROPERTIES:
:CUSTOM_ID: /docs/plain-list-and-item/#unordered-lists
:END:

The following org snippet (unordered list):

#+BEGIN_SRC text
- a thing,
- another thing,
- and the last one.
#+END_SRC

is exported by ~one~ as follow:

#+BEGIN_SRC html
<ul>
  <li>
    <p>a thing,</p>
  </li>
  <li>
    <p>another thing,</p>
  </li>
  <li>
    <p>and the last one.</p>
  </li>
</ul>
#+END_SRC

and is rendered like this:

- a thing,
- another thing,
- and the last one.

** Ordered list

The following org snippet (unordered list):

#+BEGIN_SRC text
1) first,
2) second,
3) third.
#+END_SRC

is exported by ~one~ as follow:

#+BEGIN_SRC html
<ol>
  <li>
    <p>a thing,</p>
  </li>
  <li>
    <p>another thing,</p>
  </li>
  <li>
    <p>and the last one.</p>
  </li>
</ol>
#+END_SRC

and is rendered like this:

1) first,
2) second,
3) third.
