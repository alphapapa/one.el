* TODO one.el
:PROPERTIES:
:ONE: one-default-home
:CUSTOM_ID: /
:END:

Hi, I'm [[https://tonyaldon.com][Tony Aldon]] and I'm glad that you're giving a try to [[https://github.com/tonyaldon/one.el][one.el]], a
simple static site generator for Emacs Lisp programmers and org-mode
users.  I hope its design fits your workflow.

To get started right away check [[#/docs/install-one-el/][Install one.el]] and [[#/docs/getting-started/][Getting started]]
pages.

In ~one.el~, the following org document defines a website with 3 pages
that we build by calling ~one-build~ command while we are visiting it:

#+BEGIN_SRC org
,* My website
:PROPERTIES:
:ONE: one-default-home
:CUSTOM_ID: /
:END:

Welcome to my website!

,* Blog post 1
:PROPERTIES:
:ONE: one-default
:CUSTOM_ID: /blog/page-1/
:END:

My first blog post!

,* Blog post 2
:PROPERTIES:
:ONE: one-default
:CUSTOM_ID: /blog/page-2/
:END:

My second blog post!
#+END_SRC

Note that if we want to use the default css style sheet we can add it
by calling ~one-default-add-css-file~ before building the website.

The path ~/~ in the first ~CUSTOM_ID~ org property tells ~one.el~ that the
page "My website" is the home page.  That page is rendered using
~one-default-home~ render function, value of ~ONE~ org property of the
same headline.

The path ~/blog/page-1/~ in the second ~CUSTOM_ID~ org property tells
~one.el~ that we want to render "Blog post 1" page in such a way
that when we serve our website locally at ~http://localhost:3000~ for
instance, that page is served at ~http://localhost:3000/blog/page-1/~.
How that page is rendered is determined by the value of ~ONE~ org
property of the same headline which is ~one-default~, a render
function.

The same goes for the last page "Blog post 2".

As you might have noticed, a ~one.el~ website is an org file where the
pages are the headlines of level 1 with the org properties ~ONE~ and
~CUSTOM_ID~ set.  Nothing more!

~ONE~ is the only org property added by ~one.el~.  Its value (an Elisp
function which returns an HTML string) for a given page determines how
~one.el~ renders that page.

Paths of pages are set using ~CUSTOM_ID~ org property.

With that said, if you want to try it you can check [[#/docs/install-one-el/][Install one.el]] and
[[#/docs/getting-started/][Getting started]] pages.

** Why one.el?

I wrote ~one.el~ to do tech blogging.  More precisely to talk about
programs (not programming).

To me, it involves only three components:

1) chunks of code,
2) links to those chunks of code and,
3) the people who wrote those chunks of code.

So, when I wrote it, I focused on those aspects.

As a result, I left out many org elements.  You can check [[#/docs/one-ox/][one-ox]] org
backend page for more information.

* Install one.el
:PROPERTIES:
:ONE: one-default-doc
:CUSTOM_ID: /docs/install-one-el/
:END:

~one.el~ depends on [[https://jack.tonyaldon.com/][jack]] and [[https://github.com/hniksic/emacs-htmlize][htmlize]] packages that are available on
[[https://melpa.org/][Melpa]].  Once you have them installed you can add ~one.el~ to your
~load-path~ and require it like this:

#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "/path/to/one.el/")
(require 'one)
#+END_SRC

If you're using [[https://github.com/radian-software/straight.el][straight.el]], to install ~one.el~ you just have to add
this sexp to your init file:

#+BEGIN_SRC emacs-lisp
(straight-use-package
 '(one :type git :host github :repo "tonyaldon/one.el"))
#+END_SRC

Now you can create a new website by calling ~one-default-new-project~
(preferably in an empty directory) and you can build it by calling
~one-build~ command.

If this is the first time you try ~one.el~ reading [[#/docs/getting-started/][Getting started]]
page might be helpful.

* Getting started
:PROPERTIES:
:ONE: one-default-doc
:CUSTOM_ID: /docs/getting-started/
:END:
** Start a new project

By calling ~one-default-new-project~ command (preferably in an empty
directory) we produce a new ~one.el~ project with the following
structure:

#+BEGIN_SRC text
.
├── assets
│   └── one.css
└── one.org
#+END_SRC

Once done we can build the website under the directory ~./public/~
by calling ~one-build~ command while we are in the file ~one.org~.  Our
project's structure is now:

#+BEGIN_SRC text
.
├── assets
│   └── one.css
├── one.org
└── public
    ├── blog
    │   ├── default
    │   │   └── index.html
    │   ├── default-home-list-pages
    │   │   └── index.html
    │   ├── one-default-doc
    │   │   └── index.html
    │   └── one-default-with-toc
    │       └── index.html
    ├── index.html
    └── one.css
#+END_SRC

** Modify the content with live reloading

To get our website up and running, we serve the files in ~./public/~
subdirectory using [[https://browsersync.io][brower-sync]] (any webserver serving files is OK).
Once we have it installed, to start a webserver with live reloading,
we run the following commands (in a terminal):

#+BEGIN_SRC text
$ cd public
$ browser-sync start -s -w --files "*"
#+END_SRC

Assuming the port ~3000~ isn't used we have our website served at
~http://localhost:3000~.

Now we can modify the content of ~one.org~ file and see the changes
reflected in the browser after we rebuild/re-render the whole website
or part of it using the following commands ~one-build~, ~one-render-pages~
and ~one-render-page-at-point~ or the asynchronous version of those
commands ~one-build-async~, ~one-render-pages-async~ and
~one-render-page-at-point-async~.

** CSS style sheet

When we call ~one-build~ (or ~one-build-async~) command the pages of the
website are rendered in the directory ~./public/~ and the files in
~./assets/~ directory are copied into ~./public/~ subdirectory.

When we build a ~one.el~ website with the default render functions and
the default CSS style sheet (this is the case if we used
~one-default-new-project~ as we did above) the style sheet that applies
is ~./public/one.css~ file which is a copy of ~./assets/one.css~ file.

So in that case, to modify the website's layout we just have to modify
the file ~./assets/one.css~ and copy it in ~./public/~ directory either
with ~one-build~, ~one-build-async~ or ~one-copy-assets-to-public~.

*** Modify the CSS style sheet with live reloading

To get the file ~./assets/one.css~ copied into ~./public/~ directory each
time we modify it we can use [[https://eradman.com/entrproject/][entr]] utility like this (being at the root
of our project):

#+BEGIN_SRC text
$ ls assets/one.css | entr -s 'cp assets/one.css public/'
#+END_SRC

Combined with ~browser-sync~ live reloading I think we get a decent
programmer experience.

*** Source blocks

When we use the default render functions and the default CSS style
sheet, the org content is exported into HTML strings using ~one~ org
export backend.  Consequently, ~src-block~ elements are highlighted
using [[https://github.com/hniksic/emacs-htmlize][htmlize]].

See [[#/docs/one-ox-src-block/][one-ox | src-block]] for more information.

* How does one.el work?
:PROPERTIES:
:ONE: one-default-doc
:CUSTOM_ID: /docs/how-does-one-el-work/
:END:

In an org file containing all the pages of our website we can build
the website under ~./public/~ subdirectory by calling either ~one-build~
or ~one-render-pages~ commands.

The only difference between those two commands is that before
producing the HTML pages calling ~one-render-pages~, ~one-build~ command
cleans the subdirectory ~./public/~ and copies the content of ~./assets/~
subdirectory into ~./public/~ subdirectory.

So let's focus on ~one-render-pages~ command.

For each page of our website, the function ~one-render-pages~ uses
the render function set in ~ONE~ org property of the page to produce the
HTML string representing the page and stores it in an ~index.html~ file
whom path is determined by ~CUSTOM_ID~ org property of the page.

Render functions are at the heart of ~one.el~ mechanism.  They
determined how pages are rendered.  Specifically, render functions are
regular Elisp functions that takes 3 arguments

- ~page-tree~: corresponding to the parsed tree of the org entry defining
  the page,
- ~pages~: the list of pages,
- ~global~: a plist of global informations that are computed once
  in ~one-render-pages~ (see ~one-add-to-global~) before rendering the
  pages

and return HTML strings.

For instance, the following ~hello-world~ function

#+BEGIN_SRC emacs-lisp
(defun hello-world (page-tree pages global)
      "<h1>Hello world!</h1>")
#+END_SRC

defines a valid render function.  We can use it to build a website
like this.  In an empty directory, we create a file named ~one.org~ with
the following content:

#+BEGIN_SRC org
,* The home page
:PROPERTIES:
:ONE: hello-world
:CUSTOM_ID: /
:END:
,* Blog post 1
:PROPERTIES:
:ONE: hello-world
:CUSTOM_ID: /blog/page-1/
:END:
#+END_SRC

We visit that file and call ~one-build~ command.  It produces the
following files

#+BEGIN_SRC text
.
├── one.org (already there)
└── public
    ├── blog
    │   └── page-1
    │       └── index.html
    └── index.html
#+END_SRC

and both files ~./public/blog/page-1/index.html~ and
~./public/index.html~ have the same content:

#+BEGIN_SRC html
<h1>Hello world!</h1>
#+END_SRC

Therefore if we serve the website in ~./public/~ directory at
~http://localhost:3000~ we can access the two "Hello world!" pages
at ~http://localhost:3000/blog/page-1/~ and ~http://localhost:3000~.

That's it!  This is how ~one.el~ works under the hood.

~one.el~ comes with predefined render functions, a custom CSS style
sheet and a custom [[#/docs/one-ox/][org export backend]] which are used all together to
build that documentation for instance.

See [[#/docs/getting-started/][Getting started]] to start a new project with those defaults.

See [[#/docs/the-default-website/][The default website]] to take inspiration and write your own render
functions.

* TODO The default website
:PROPERTIES:
:ONE: one-default-doc
:CUSTOM_ID: /docs/the-default-website/
:END:

# TO BE CONTINUED...
# modified a bit hello-world render function to use jack and one-ox
# org backend with org-export-data-with-backend
# - write your own render function - copy/past one-default
# - add org property to a page and get it and render it via your own
#   render function
# - missing transcoder function (for instance ~horizontal-rule~), how to
#   defined a derived org backend from ~one~ backend + also tables with
#   ~ox-html~...
# - make them try the function ~org-element-parse-buffer~:
#     M-x pp-eval-expression RET (org-element-parse-buffer)

To facilitate the generation of the HTML strings in render functions
we can use the package [[https://jack.tonyaldon.com][Jack]] as in ~one-default~ function:

#+BEGIN_SRC emacs-lisp
(defun one-default (page-tree pages global)
  "..."
  (let* ((title (org-element-property :raw-value page-tree))
         (path (org-element-property :CUSTOM_ID page-tree))
         (content (org-export-data-with-backend
                   (org-element-contents page-tree)
                   'one nil))
         (website-name (one-default-website-name pages))
         (nav (one-default-nav path pages)))
    (jack-html
     "<!DOCTYPE html>"
     `(:html
       (:head
        (:meta (@ :name "viewport" :content "width=device-width,initial-scale=1"))
        (:link (@ :rel "stylesheet" :type "text/css" :href "/one.css"))
        (:title ,title))
       (:body
        (:div.header (:a (@ :href "/") ,website-name))
        (:div.content
         (:div.title (:h1 ,title))
         ,content
         ,nav))))))
#+END_SRC


# Links to pages
#
# Note that the previous links is written in the org file like this
#
# #+BEGIN_SRC text
# [[#/docs/one-default-with-toc/][The default page with a TOC]]
# #+END_SRC
#
# making it an internal org link that targets the entry in the same file
# with the ~CUSTOM_ID~ property set to ~/docs/one-default-with-toc/~ and the
# render function ~one-default~ renders it like this:
#
# #+BEGIN_SRC html
# <a href="/docs/one-default-with-toc/">The default page with a TOC</a>
# #+END_SRC
#
# The advantage of doing this is that the navigation between pages
# (level 1 headlines with ~ONE~ and ~CUSTOM_ID~ org properties set) inside
# Emacs is the same as in the browser once the website has been built.
#
# ----
#
# Why does one-default render links in this way?
#
# This is because ~one-default~ render function uses ~one~ org export
# backend internally to convert the parsed tree of this page into an
# HTML string.  And ~one~ backend is designed to do the right thing for
# links, code blocks and headlines in the context of ~one~.
#
# To convert the parsed tree of this page into an HTML string,
# ~one-default~ uses the function ~org-export-data-with-backend~ like this
#
# #+BEGIN_SRC emacs-lisp
# (org-export-data-with-backend
#  (org-element-contents page-tree)
#  'one nil)
# #+END_SRC
#
# where ~page-tree~ is the parsed tree of the entry of this page given as
# the first argument of ~one-default~.

# So all the interesting work is done by ~one-render-pages~ command.
# When we call it in an org buffer containing all our pages,
# ~one-render-pages~ does the following:
#
# 1) set ~tree~ local variable to the parsed tree of the current org
#    buffer,
# 2) set ~pages~ local variable to the list of pages in ~tree~,
# 3) set ~global~ local variable according to the information in
#    ~one-add-to-global~ user variable,
# 4) call the functions in ~one-hook~ with the previously computed
#    variables ~tree~, ~pages~ and ~global~ as arguments,
# 5) finally produce the HTML pages in ~./public/~ subdirectory doing the
#    following.  For each ~page~ in ~pages~:
#    - set ~path~, ~render-page-function~, ~page-tree~ local variables
#      using respectively the values of the properties ~:one-path~,
#      ~:one-render-page-function~, ~:one-page-tree~ in ~page~ property list,
#    - fill the content of a new created file ~index.html~ in the
#      subdirectory ~path~ with the HTML string generated by
#      ~render-page-function~ function called with ~page-tree~, ~pages~ and
#      ~global~ as arguments.
#
# Here is the complete implementation of ~one-render-pages~:
#
# #+BEGIN_SRC emacs-lisp
# (defun one-render-pages ()              ;
#   "..."
#   (interactive)
#   (let* ((tree (one-parse-buffer))
#          (pages (one-list-pages tree))
#          (global
#           (let (global)
#             (dolist (glob one-add-to-global)
#               (push (funcall (plist-get glob :one-global-function) pages tree)
#                     global)
#               (push (plist-get glob :one-global-property) global))
#             global)))
#     (dolist (hook one-hook) (funcall hook pages tree global))
#     (dolist (page pages)
#       (let* ((path (concat "./public" (plist-get page :one-path)))
#              (file (concat path "index.html"))
#              (render-page-function (plist-get page :one-render-page-function))
#              (page-tree (plist-get page :one-page-tree)))
#         (make-directory path t)
#         (with-temp-file file
#           (insert (funcall render-page-function page-tree pages global)))))))
# #+END_SRC

** TODO The default page
:PROPERTIES:
:ONE: one-default
:CUSTOM_ID: /docs/default/
:END:

This page is rendered with the default render function ~one-default~
specified in ~ONE~ org property.  The path of the page is specified in
~CUSTOM_ID~ org property.  Notice that it starts with a slash ~/~ and end
with a slash ~/~.

*** Do you want a table of content?

As we can see, ~one-default~ doesn't add a table of content (TOC). If we
want a default render function that adds the TOC to the page we can
use the render function ~one-default-with-toc~ presented in [[#/docs/one-default-with-toc/][The default
page with a TOC]].

** TODO The default page with a TOC
:PROPERTIES:
:ONE: one-default-with-toc
:CUSTOM_ID: /docs/one-default-with-toc/
:END:

This page is rendered with the render function ~one-default-with-toc~
specified in the org property ~ONE~.

*** Do you want a sidebar?

Perhaps we want a sidebar listing all the pages on your website, as
many modern documentation sites do.  If so, we can use the default
render function ~one-default-doc~ presented in [[#/docs/one-default-doc/][The default page with TOC
and sidebar]].

** TODO The default page with TOC and sidebar
:PROPERTIES:
:ONE: one-default-doc
:CUSTOM_ID: /docs/one-default-doc/
:END:

This page is rendered with the function ~one-default-doc~ specified
in the org property ~ONE~.

*** headline 1
**** headline 1.1

foo

**** headline 1.2

bar

*** headline 2
** TODO Alternative default render function for the home page
:PROPERTIES:
:ONE: one-default-home
:CUSTOM_ID: /default-home/
:END:

# This page is rendered with the default render function
# ~one-default-home-list-pages~ specified in ~ONE~ org property.  Being the
# website's home page, its path specified in ~CUSTOM_ID~ org property is
# set to one slash ~/~.
#
# Thus this text is inserted before we list the website's pages (in
# reverse order of appearance in the org document).
#
# We can change this page's appearance by modifying the CSS ids
# ~home-list-pages~ and ~pages~, and the CSS classes ~header~ and ~content~.
#
# And if we don't want to list the website's pages we can use the
# default render function ~one-default-home~ presented in [[#/default-home/][Alternative
# default render function for the home page]].


# This page is rendered with the default render function ~one-default-home~
# specified in ~ONE~ org property.
#
# And as we can see the website's pages are not listed and the content
# is rendered "normaly" (not text centered as in the [[#/][home page]]).
#
# We can change this page's appearance by modifying the CSS id
# ~home~ and the CSS classes ~header~ and ~content~.
#
# Let's move on to [[#/blog/default/][The default page]].

* TODO onerc.el "config" file
:PROPERTIES:
:ONE: one-default-doc
:CUSTOM_ID: /docs/.../
:END:
* TODO async functions
:PROPERTIES:
:ONE: one-default-doc
:CUSTOM_ID: /docs/.../
:END:
* one-ox
:PROPERTIES:
:ONE: one-default-doc
:CUSTOM_ID: /docs/one-ox/
:END:
** Org export backend used by the default render functions

~one.el~ (specifically the default render functions) uses its own org
export backend called ~one~ to export the org content of the pages into
HTML strings.

For instance, the render function ~one-default~ takes as first argument
~page-tree~ which is the current page being rendered (~page-tree~ is the
org parsed data structure representing the page) and exports it as an
HTML string using ~org-export-data-with-backend~ function and ~one~ export
backend and uses it to render the HTML page:

#+BEGIN_SRC emacs-lisp
(defun one-default (page-tree pages _global)
  "..."
  (let* (...
         (content (org-export-data-with-backend
                   (org-element-contents page-tree)
                   'one nil))
         ...)
    (jack-html
     "<!DOCTYPE html>"
     `(:html
       (:head ...)
       (:body ... (:div.content ... ,content ,nav))))))
#+END_SRC

This org backend is taylor for ~one.el~ usage.  So it doesn't try to
export all the org elements unlike ~html~ backend and when the org
elements are exported they differ from what we can expect from ~html~
backend.

For instance ~headline~ elements don't take into account markups
neither links.

Another example are the ~link~ elements.  They don't support org fuzzy
links and links to local files that are not in the subdirectories
~./public/~ or ~./assets/~ raise errors.

You can read how the supported org elements are exported by ~one~ org
backend in the following page:

- [[#/docs/one-ox-headline/][one-ox | headline]],
- [[#/docs/one-ox-src-block/][one-ox | src-block]],
- [[#/docs/one-ox-quote-block/][one-ox | quote-block]],
- [[#/docs/one-ox-fixed-width-and-example-block/][one-ox | fixed-width and example-block]],
- [[#/docs/one-ox-links/][one-ox | links]] and
- [[#/docs/one-ox-plain-list/][one-ox | plain-list]].

** Org elements not supported

The org elements that are not supported are the following:
~center-block~, ~clock~, ~drawer~, ~dynamic-block~, ~entity~, ~export-block~,
~export-snippet~, ~footnote-reference~, ~horizontal-rule~, ~inline-src-block~,
~inlinetask~, ~keyword~, ~latex-environment~, ~latex-fragment~, ~line-break~,
~node-property~, ~planning~, ~property-drawer~, ~radio-target~, ~special-block~,
~statistics-cookie~, ~table~, ~table-cell~, ~table-row~, ~target~, ~timestamp~,
~verse-block~.

Note that "not supported" means they are not rendered by default by
~one.el~ but we can still use them or even extend ~one~ org export
backend to take some of them into account.

Why doesn't ~one.el~ support all org elements?

1. I don't need those org elements to write my tech blogs:

   - I don't do math.  No support for Latex,
   - I don't use table.  No support for tables,
   - etc.

2. ~one~ org backend is used only by the default render functions, so if
   you need more org elements you can either use another org backend
   or extend ~one~ org backend and use this other org backend in your
   own render functions.

* one-ox | headline
:PROPERTIES:
:ONE: one-default-doc
:CUSTOM_ID: /docs/one-ox-headline/
:END:

Note that markups and links are not exported if used in headlines, only
the raw value string.

So don't use them in headlines.

* one-ox | src-block
:PROPERTIES:
:ONE: one-default-doc
:CUSTOM_ID: /docs/one-ox-src-block/
:END:
** Code highlighting with htmlize
*** Description

~one~ highlights code via the function ~one-ox-htmlize~ that uses
[[https://github.com/hniksic/emacs-htmlize][htmlize]] to do the work.

For a given piece of code ~X~ in a certain language ~Y~, ~X~ will be
highlighted as it would be in the emacs mode ~Z~ used to edit ~Y~ code.

For instance, ~clojure-mode~ is used to highlight Clojure code and
~sh-mode~ is used to highlight Bash code.

Attributes of a face (like ~background-color~ or ~foreground-color~)
are not taken directly.  A generated name for the face is produced and
used as the CSS class for the parts of the code ~X~ that are highlighted
with that face.

For instance, in ~sh-mode~, the word ~echo~ is highlighted with the face
~font-lock-builtin-face~.  So, the word ~echo~ in a piece of Shell (or
Bash) code will be transformed into:

#+BEGIN_SRC html
<span class="one-hl-builtin">echo</span>
#+END_SRC

The whole piece of code ~X~, once the previously described operations
have been done, is wrapped:

1) for a normal block with the component:

   #+BEGIN_SRC html
   <pre><code class="one-hl one-hl-block">...</code></pre>
   #+END_SRC

2) for a result block with the component:

   #+BEGIN_SRC html
   <pre><code class="one-hl one-hl-results">...</code></pre>
   #+END_SRC

   See section [[#/docs/one-ox-src-block/#org-keywords-results-and-attr_one_results][org keyword RESULTS]].

*** Example with Bash code

For instance, the following org src-block, containing some ~bash~ code:

#+BEGIN_SRC text
,#+BEGIN_SRC bash
echo "list file's extensions in current dir:"
for f in `ls`; do
    echo ${f##*.}
done
,#+END_SRC
#+END_SRC

is exported as follow:

#+BEGIN_SRC html
<pre><code class="one-hl one-hl-block"><span class="one-hl-builtin">echo</span> <span class="one-hl-string">"list file's extensions in current dir:"</span>
<span class="one-hl-keyword">for</span> f<span class="one-hl-keyword"> in</span> <span class="one-hl-sh-quoted-exec">`ls`</span>; <span class="one-hl-keyword">do</span>
    <span class="one-hl-builtin">echo</span> ${<span class="one-hl-variable-name">f</span>##*.}
<span class="one-hl-keyword">done</span></code></pre>
</div>
#+END_SRC

and rendered like this:

#+BEGIN_SRC bash
echo "list file's extensions in current dir:"
for f in `ls`; do
    echo ${f##*.}
done
#+END_SRC

Note that ~one-ox-htmlize~ has produced and used the following CSS
classes (listed with their corresponding emacs faces):

#+BEGIN_SRC text
# from font-lock
one-hl-builtin        --> font-lock-builtin-face
one-hl-keyword        --> font-lock-keyword-face
one-hl-string         --> font-lock-string-face
one-hl-variable-name  --> font-lock-variable-name-face

# specific to sh-mode
one-hl-sh-quoted-exec --> sh-quoted-exec
#+END_SRC

You might have notice the pattern used for ~font-lock~ faces and the one
used for mode specific faces.

~one.el~ provides a default style sheet (~one-default-css~) that has the
CSS classes defined for all the ~font-lock~ faces (faces starting by
~font-lock-~) but not the specific faces used by each prog mode.

You can add the CSS classes specific to the prog modes you use as you
go and need them.

** Org keyword RESULTS
:PROPERTIES:
:CUSTOM_ID: /docs/one-ox-src-block/#org-keywords-results-and-attr_one_results
:END:

Result blocks are preceded by a line starting with ~#+RESULTS:~.  Blocks
that are not result blocks are normal blocks.

When exported, normal blocks and result blocks differ only by their
CSS classes:

- ~one-hl one-hl-block~ for normal blocks,
- ~one-hl one-hl-results~ for result blocks.

This way result blocks can be rendered with a different style
than normal blocks as we can see in the following example.

*** Example using org keyword 'RESULTS'

The following org snippet:

#+BEGIN_SRC text
,#+BEGIN_SRC bash :results output
ls
,#+END_SRC

,#+RESULTS:
: content.org
: one.css
: one.el
: README.org
#+END_SRC

is exported by ~one~ as follow:

#+BEGIN_SRC html
<pre><code class="one-hl one-hl-block">ls</code></pre>
<pre><code class="one-hl one-hl-results">content.org
one.css
one.el
README.org</code></pre>
#+END_SRC

and is rendered by ~one~ with the first block (normal block) having a
different style from second block (result block):

#+BEGIN_SRC bash :results output
ls
#+END_SRC

#+RESULTS:
: content.org
: one.css
: one.el
: README.org

** Code blocks inside list

Lists can contain source blocks as we can see in the following org
snippet

#+BEGIN_SRC text
1. item 1

   ,#+BEGIN_SRC emacs-lisp
   (message "src-block in item 1")
   ,#+END_SRC

2. item 2
3. item 3
#+END_SRC

which is exported by ~one~ as follow

#+BEGIN_SRC html
<ol>
  <li>
    <p>item 1</p>
    <pre><code class="one-hl one-hl-block">(message <span class="one-hl-string">"src-block in item 1"</span>)</code></pre>
  </li>
  <li><p>item 2</p></li>
  <li><p>item 3</p></li>
</ol>
#+END_SRC

and is rendered by ~one~ like this:

1. item 1

   #+BEGIN_SRC emacs-lisp
   (message "src-block in item 1")
   #+END_SRC

2. item 2
3. item 3

* one-ox | quote-block
:PROPERTIES:
:ONE: one-default-doc
:CUSTOM_ID: /docs/one-ox-quote-block/
:END:

Blocks defined with ~#+BEGIN_QUOTE ... #+END_QUOTE~ pattern are
quote-block.

They are exported by ~one~ in a ~<blockquote>...</blockquote>~ component
with the CSS class ~one-blockquote~.

The following org snippet:

#+BEGIN_SRC text
,#+BEGIN_QUOTE
A quitter never wins and a winner never quits. —Napoleon Hill
,#+END_QUOTE
#+END_SRC

defines a quote and is exported by ~one~ as follow

#+BEGIN_SRC html
<blockquote class="one-blockquote"><p>A quitter never wins and a winner never quits. —Napoleon Hill</p></blockquote>
#+END_SRC

and looks like this

#+BEGIN_QUOTE
A quitter never wins and a winner never quits. —Napoleon Hill
#+END_QUOTE

* one-ox | fixed-width and example-block
:PROPERTIES:
:ONE: one-default-doc
:CUSTOM_ID: /docs/one-ox-fixed-width-and-example-block/
:END:
** Description

A line starting with a colon ~:~ followed by a space defines a
~fixed-width~ element.  A ~fixed-width~ element can span several
lines.

Blocks defined with ~#+BEGIN_EXAMPLE ... #+END_EXAMPLE~ pattern are
~example-block~ elements.

Both ~fixed-width~ and ~example-block~ blocks are treated as [[#/docs/one-ox-src-block/][src-block]] in
~text-mode~.  So:

1. they are highlighted as ~text-mode~ would do,
2. they are exported in ~<pre><code>...</code></pre>~ components
   (indentation and newlines are respected) and
3. the CSS classes used depend on the block's type:

   - normal blocks use ~one-hl one-hl-block~ CSS classes and
   - result blocks use ~one-hl one-hl-results~ CSS classes (see [[#/docs/one-ox-src-block/#org-keywords-results-and-attr_one_results][org
     keyword RESULTS]]).

** Example

The following org snippet

#+BEGIN_SRC text
Here is a ~fixed-width~ element (one line):

: I'm a fixed-width element

~fixed-width~ elements can also be used within lists:

- item 1

  : fixed-width element

- item 2

  ,#+BEGIN_SRC bash :results output
  printf 'multiline fixed-width element\nthat is also a result block,\nso has a different style.'
  ,#+END_SRC

  ,#+RESULTS:
  : multiline fixed-width element
  : that is also a result block,
  : so has a different style.

Although I don't often use ~example-block~ elements, here is one:

,#+BEGIN_EXAMPLE
This    is
        an    example!
,#+END_EXAMPLE
#+END_SRC

is exported by ~one~ as follow

#+BEGIN_SRC html
<p>Here is a <code class="one-hl one-hl-inline">fixed-width</code> element (one line):
</p>

<pre><code class="one-hl one-hl-block">I'm a fixed-width element</code></pre>


<p><code class="one-hl one-hl-inline">fixed-width</code> elements can also be used within lists:
</p>

<ul><li><p>item 1
</p>

<pre><code class="one-hl one-hl-block">fixed-width element</code></pre>
</li>

<li><p>item 2
</p>

<pre><code class="one-hl one-hl-block"><span class="one-hl-builtin">printf</span> <span class="one-hl-string">'multiline fixed-width element\nthat is also a result block,\nso has a different style.'</span></code></pre>

<pre><code class="one-hl one-hl-results">multiline fixed-width element
that is also a result block,
so has a different style.</code></pre>
</li>
</ul>

<p>Although I don&apos;t often use <code class="one-hl one-hl-inline">example-block</code> elements, here is one:
</p>

<pre><code class="one-hl one-hl-block">This    is
        an    example!</code></pre>
#+END_SRC

and looks like this:

Here is a ~fixed-width~ element (one line):

: I'm a fixed-width element

~fixed-width~ elements can also be used within lists:

- item 1

  : fixed-width element

- item 2

  #+BEGIN_SRC bash :results output
  printf 'multiline fixed-width element\nthat is also a result block,\nso has a different style.'
  #+END_SRC

  #+RESULTS:
  : multiline fixed-width element
  : that is also a result block,
  : so has a different style.

Although I don't often use ~example-block~ elements, here is one:

#+BEGIN_EXAMPLE
This    is
        an    example!
#+END_EXAMPLE

* one-ox | links
:PROPERTIES:
:ONE: one-default-doc
:CUSTOM_ID: /docs/one-ox-links/
:END:
** http, https, mailto links

Web links (starting by ~http~ or ~https~) and links to message
composition (starting by ~mailto~) are exported as we expect.

For instance the following link

#+BEGIN_SRC text
http://tonyaldon.com
#+END_SRC

is exported as follow

#+BEGIN_SRC html
<a href="http://tonyaldon.com">http://tonyaldon.com</a>
#+END_SRC

and rendered like this: http://tonyaldon.com.

This following link with a description

#+BEGIN_SRC text
[[https://tonyaldon.com][Tony Aldon (https)]]
#+END_SRC

is exported as follow

#+BEGIN_SRC html
<a href="https://tonyaldon.com">Tony Aldon (https)</a>
#+END_SRC

and rendered like this: [[https://tonyaldon.com][Tony Aldon (https)]].

This ~mailto~ link

#+BEGIN_SRC text
[[mailto:tony@tonyaldon.com][send me an email]]
#+END_SRC

is exported as follow

#+BEGIN_SRC html
<a href="mailto:tony@tonyaldon.com">send me an email</a>
#+END_SRC

and rendered like this: [[mailto:tony@tonyaldon.com][send me an email]].

** Custom ID links

In ~one.el~, ~CUSTOM_ID~ org property is used to defined the path of pages
or the path to specific heading in pages.

Considering the following org document

#+BEGIN_SRC text
,* Home Page
:PROPERTIES:
:ONE: one-default-home
:CUSTOM_ID: /
:END:

- [[#/blog/page-1/]]
- [[#/blog/page-1/#headline-1]]

,* Page 1
:PROPERTIES:
:ONE: one-default
:CUSTOM_ID: /blog/page-1/
:END:
,** headline 1 in page Page 1
:PROPERTIES:
:CUSTOM_ID: /blog/page-1/#headline-1
:END:
#+END_SRC

the link ~[[#/blog/page-1/]]~ in "Home Page" targets "Page 1" page
and the link ~[[#/blog/page-1/#headline-1]]~ in "Home Page" targets the
heading "headline 1 in page Page 1" in the "Page 1" page.

Those paths define valid web urls starting at the root of the website
if we respect the following rules for ~CUSTOM_ID~ values:

1. we use only url-encoded characters,
2. we start them with a ~/~ and end them with ~/~,
3. we use ~#~ character to start the last part of the path when we are
   targeting a heading tag with its ~id~ being the last part after the ~#~
   character.

The benefits of these "rules/conventions" are:

1. when we export ~custom-id~ links using ~one~ org backend we can leave
   them as they are and
2. the navigation between pages inside emacs using ~custom-id~ links
   works out-of-the-box.

*** Example of a link to a page

The following link

#+BEGIN_SRC text
[[#/docs/one-ox-plain-list/][one-ox | plain-list]]
#+END_SRC

is exported to this anchor tag that links to the page ~/docs/one-ox-plain-list/~:

#+BEGIN_SRC html
<a href="/docs/one-ox-plain-list/">one-ox | plain-list</a>
#+END_SRC

and is rendered like this [[#/docs/one-ox-plain-list/][one-ox | plain-list]].

*** Example of a link to a heading in a page

The following link

#+BEGIN_SRC text
[[#/docs/one-ox-plain-list/#unordered-lists][unordered lists heading in the page about plain-list]]
#+END_SRC

is exported to this anchor tag that links to the heading with the ~id~
set to ~unordered-lists~ on the page ~/docs/one-ox-plain-list/~:

#+BEGIN_SRC html
<a href="/docs/one-ox-plain-list/#unordered-lists">unordered lists heading in the page about plain-list</a>
#+END_SRC

and is rendered like this [[#/docs/one-ox-plain-list/#unordered-lists][unordered lists heading in the page about
plain-list]].

** Fuzzy links

I don't use ~fuzzy~ links.  So, if there is a ~fuzzy~ link
in the document, that means I wrote the link wrong.

Broken links are bad user experience.  I don't like them.

So I decided that ~one~ raises an error (hard-coded) when we try to
export a fuzzy link to HTML.

For instance, the following ~fuzzy~ link:

#+BEGIN_SRC text
[[fuzzy search]]
#+END_SRC

raise an error like the following:

#+BEGIN_SRC text
(one-link-broken "fuzzy search" "fuzzy links not supported" "goto-char: 5523")
#+END_SRC

** File links
*** Links to local files in assets and public directories

Links to local files in ~./assets/~ and ~./public/~ directories like

#+BEGIN_SRC text
[[./assets/foo/bar.txt][Bar file]]
[[./public/foo/baz.txt][Baz file]]
#+END_SRC

are exported with the prefixes ~./assets~ and ~./public~ of the path
removed like this:

#+BEGIN_SRC html
<a href="/foo/bar.txt">Bar file</a>
<a href="/foo/baz.txt">Baz file</a>
#+END_SRC

*** Local file links that raise one-link-broken error

Any file link that doesn't point to a file in ~./assets/~ or ~./public/~
subdirectories raises an ~one-link-broken~ error when we try to
export it with ~one~ org backend

For instance if we try to export using ~one~ org backend the following
link to the file ~foo.txt~ in the directory ~/tmp/~

#+BEGIN_SRC text
[[/tmp/foo.txt]]
#+END_SRC

which is not in ~./public/~ subdirectory nor in ~./assets/~ subdirectory
we will get an error like the following:

#+BEGIN_SRC text
(one-link-broken "/tmp/" "goto-char: 26308")
#+END_SRC

*** Links to images

Links to local files in ~./assets/~ and ~./public/~ directories whom path
matches ~one-ox-link-image-extensions~ regexp are exported with an ~img~
tag.

For instance the following link to an image in ~./assets/img/~ directory

#+BEGIN_SRC text
[[./assets/img/keep-learning.png][Keep Learning]]
#+END_SRC

is exported as follow

#+BEGIN_SRC html
<img href="/img/keep-learning.png" alt="Keep Learning"></a>
#+END_SRC

and rendered like this

[[./assets/img/keep-learning.png][Keep Learning]]

* one-ox | plain-list and item
:PROPERTIES:
:ONE: one-default-doc
:CUSTOM_ID: /docs/one-ox-plain-list/
:END:

Only unordered and ordered lists are supported.

** Unordered lists
:PROPERTIES:
:CUSTOM_ID: /docs/one-ox-plain-list/#unordered-lists
:END:

The following org snippet (unordered list):

#+BEGIN_SRC text
- a thing,
- another thing,
- and the last one.
#+END_SRC

is exported by ~one~ as follow

#+BEGIN_SRC html
<ul>
  <li>
    <p>a thing,</p>
  </li>
  <li>
    <p>another thing,</p>
  </li>
  <li>
    <p>and the last one.</p>
  </li>
</ul>
#+END_SRC

and is rendered like this:

- a thing,
- another thing,
- and the last one.

** Ordered list

The following org snippet (unordered list):

#+BEGIN_SRC text
1. first,
2. second,
3. third.
#+END_SRC

is exported by ~one~ as follow

#+BEGIN_SRC html
<ol>
  <li>
    <p>a thing,</p>
  </li>
  <li>
    <p>another thing,</p>
  </li>
  <li>
    <p>and the last one.</p>
  </li>
</ol>
#+END_SRC

and is rendered like this:

1. first,
2. second,
3. third.
